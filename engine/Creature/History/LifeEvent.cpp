#ifdef _MSC_VER
#pragma warning(disable:4786 4503)
#endif

#include "LifeEvent.h"
#include "../../CreaturesArchive.h"

CreaturesArchive &operator<<( CreaturesArchive &archive, LifeEvent const &lifeEvent )
{
	archive << (int)lifeEvent.myEventType;

	archive << lifeEvent.myWorldTick;
	archive << lifeEvent.myAgeInTicks;
	archive << lifeEvent.myRealWorldTime;
	archive << lifeEvent.myLifeStage;
	
	archive << lifeEvent.myRelatedMoniker1;
	archive << lifeEvent.myRelatedMoniker2;

	archive << lifeEvent.myUserText;
	archive << lifeEvent.myPhoto;

	archive << lifeEvent.myWorldName;
	archive << lifeEvent.myWorldUniqueIdentifier;

	archive << lifeEvent.myNetworkUser;
	archive << lifeEvent.myNetworkNeedUploading;
	archive << lifeEvent.myUploadedUserText;

	return archive;
}

CreaturesArchive &operator>>( CreaturesArchive &archive, LifeEvent &lifeEvent )
{
	int intEventType;
	archive >> intEventType;
	lifeEvent.myEventType = (LifeEvent::EventType)intEventType;

	archive >> lifeEvent.myWorldTick;
	archive >> lifeEvent.myAgeInTicks;
	archive >> lifeEvent.myRealWorldTime;
	archive >> lifeEvent.myLifeStage;

	archive >> lifeEvent.myRelatedMoniker1;
	archive >> lifeEvent.myRelatedMoniker2;

	archive >> lifeEvent.myUserText;
	archive >> lifeEvent.myPhoto;

	archive >> lifeEvent.myWorldName;
	archive >> lifeEvent.myWorldUniqueIdentifier;

	if (archive.GetFileVersion() >= 16)
		archive >> lifeEvent.myNetworkUser;
	else
		lifeEvent.myNetworkUser = "";

	if (archive.GetFileVersion() >= 23)
		archive >> lifeEvent.myNetworkNeedUploading;
	else
		lifeEvent.myNetworkNeedUploading = true;

	if (archive.GetFileVersion() >= 28)
		archive >> lifeEvent.myUploadedUserText;

	return archive;
}

bool LifeEvent::operator==(LifeEvent& other)
{
	return
		(myEventType == other.myEventType) &&
		(myWorldTick == other.myWorldTick) &&
		(myAgeInTicks == other.myAgeInTicks) &&
		(myRealWorldTime == other.myRealWorldTime) &&
		(myLifeStage == other.myLifeStage) &&
		(myRelatedMoniker1 == other.myRelatedMoniker1) &&
		(myRelatedMoniker2 == other.myRelatedMoniker2) &&
//		(myUserText == other.myUserText) && // user text can change, so don't compare it
//		(myPhoto == other.myPhoto) &&  // we don't require photos to be the same, as they can be deleted or retaken
		(myWorldName == other.myWorldName) &&
		(myWorldUniqueIdentifier == other.myWorldUniqueIdentifier);
}

LifeEvent::LifeEvent()
{
	myNetworkNeedUploading = true;
}

// static 
// Return true if the Norn was definitely present in the
// world for the event.  It's only worth tracking these
// events, as others are redundant information and make
// it impossible to detect duplicate Norns.
bool LifeEvent::CreaturePresentForEvent(EventType event)
{
	switch (event)
	{
		case typeConceived : // naturally
		case typeSpliced : // artificially
		case typeEngineered : // engineered

		case typeBorn :
		case typeNewLifeStage :
		case typeExported :
		case typeImported :
		case typeDied :

		case typeBecamePregnant :
		case typeImpregnated :
			return true;

		case typeChildBorn :
			return false;

		case typeCloned : // another conception
			return true;

		case typeClonedSource :
			return false;

		case typeWarpedOut :
		case typeWarpedIn : 
			return true;
	}

	// We can't guarantee anything about other events, as
	// they aren't generated by the engine.
	return false;
}

bool LifeEvent::CreaturePresentForEvent() const
{
	return CreaturePresentForEvent(myEventType);
}

